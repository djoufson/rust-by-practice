use std::{
    // any::type_name,
    ops::{Range, RangeInclusive},
};

fn main() {
    // let x = 5;
    // let mut y: &'static str = "Helo world";
    // println!("x is: {} and y is: {}", x, y);
    // y = "New value";
    // println!("Now y is: {}", y);

    // let v: u16 = 38_u8 as u16;
    // println!("Success! {}", v);

    // let x: i32 = 5;
    // assert_eq!("i32", type_of(&x));

    // println!("Success!");

    // assert_eq!(i8::MAX, 127);
    // assert_eq!(u8::MAX, 255);

    // println!("Success!");
    // let v1 = 247_u8 + 8;
    // let v2 = i8::checked_add(119, 8).unwrap();
    // println!("{},{}", v1, v2);

    // let v = 1_024 + 0xff + 0o77 + 0b1111_1111;
    // println!("v: {}", v);
    // assert!(v == 1597);

    // println!("Success!");

    // let x = 1_000.000_1; // f64
    // let y: f32 = 0.12; // f32
    // let z = 0.01_f64; // f64

    // assert_eq!(type_of(&x), "f64".to_string());
    // println!("Success!");

    // assert!(0.1f32 + 0.2f32 == 0.3f32);

    // println!("Success!");

    // let mut sum = 0;
    // for i in -3..=2 {
    //     sum += i
    // }

    // assert!(sum == -3);

    // for c in 'a'..='z' {
    //     println!("{}", c);
    // }

    // assert_eq!((1..4), Range { start: 1, end: 4 });
    // assert_eq!((1..=5), RangeInclusive::new(1, 5));

    // println!("Success!");

}

// Get the type of given variable, return a string representation of the type  , e.g "i8", "u8", "i32", "u32"
// fn type_of<T>(_: &T) -> String {
//     format!("{}", type_name::<T>())
// }
